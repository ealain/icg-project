\documentclass[12pt]{article}

\usepackage[a4paper,margin=2cm]{geometry}

\setlength{\marginparwidth}{0pt}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{datetime}

\usepackage{setspace}
\setstretch{1.2}

\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\usepackage{lastpage}
\renewcommand\headrulewidth{0pt}
\renewcommand\footrulewidth{0.3pt}
\fancyhead{}
\fancyfoot[C]{\thepage ~/ \pageref{LastPage}}
\pagestyle{fancy}

\usepackage{amsmath, amssymb}
\usepackage{graphicx}

\begin{document}

\title{Part 1 -- Procedural Terrain}
\author{Éloi \textsc{Alain} \and Enguerrand \textsc{Granoux} \and Josselin \textsc{Held}}
\newdate{date}{13}{04}{2017}
\date{\displaydate{date}}

\maketitle

\tableofcontents

\section{Introduction}

The starting point of our project is the homework 2 (trackball). We deleted the cube and kept our work for the grid.

\section{Mandatory parts}

\subsection{Noise}

{\it Main contributor: Éloi.}

The Perlin noise was implemented following the instructions of the slides.

A fixed (prime) number of random gradients are generated by CPU once and for all. These are available to the shader as a uniform vec2 array variable. Gradients are then thoroughly selected in the array using an offset, the cell coordinates and modulo.

To create the fractal Brownian motion, we added the contributions of our noise function using distinct frequencies. To obtain a realistic terrain, we had to set a particular amplitude for each contribution. The higher the frequency, the more little the contribution.

\subsection{Framebuffer}

{\it Main contributor: Josselin.}

The framebuffer was mainly reused from the one in the homework 4. As our starting point was the homework 2, we had to be able to render the noise on a grid. 

We adapt the structure so we could generate a noise-texture in the framebuffer. And then transfer it to the grid, so that we could use the -now- noise-texture-heightmap to modify  the height of the grid.

\subsection{Applying altitude}

{\it Main contributor: Enguerrand.}

The height setting is inspired by the homework 2. We read the height-texture in the grid\_vshader and use it to change the gl\_Position of the vertex.

\subsection{Shading}

{\it Main contributor: Éloi.}

The implementation is very similar to the homework on shading. The only difference that is worth mentioning is the way of computing the normal vectors as these are not directly available. In both following methods, we make use of \texttt{dFdx} and \texttt{dFdy}.

The first implementation used ``real'' position of the fragment, inherited from triangle interpolation. The issue is that this method requires many triangles to be drawn to prevent the user from visualizing them.

The second implementation reads the height of the fragment (given in the heightmap). From then on, to avoid aliasing, the linear interpolation must be activated when reading data from the heightmap.

\subsection{Simple terrain texture}

{\it Main contributor: Enguerrand.}

The color implementation is basic. We colore the texture regarding it's elevation. The height is the one from the fragment given in the heightmap. We then mix it with the shading to combine the two.


\section{Optional parts}

\subsection{Infinite terrain (not completed yet)}

To give the impression of infinite terrain, we would place the camera right above the center of the grid. To ``move'' in the terrain, the user would press the arrow keys. Technically, when pressing the arrow keys, the position of the cells (heightmap) change with time. The cell position change should depends of the view vector.

\section{Fraction of the Workload}


\begin{enumerate}
\item Éloi Alain: 40\%
\item Enguerrand Granoux: 30\%
\item Josselin Held: 30\%
\end{enumerate}

\section{Screenshot}

\begin{center}
\includegraphics[width=15cm]{screeMontain.png}
\end{center}
\end{document}
%  LocalWords:  Éloi Alain Enguerrand Granoux Josselin Perlin shader
%  LocalWords:  vec Framebuffer heightmap dFdx dFdy
